---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Fast by Default">
  <main class="min-h-screen bg-gray-50 py-16 px-4">
    <div class="max-w-4xl mx-auto">
      <article class="prose prose-lg prose-h2:mb-2 prose-h2:text-slate-700 prose-strong:font-semibold prose-strong:text-slate-600 mx-auto">
        <h1
          class="bg-gradient-to-r from-slate-800 to-slate-700 text-white -ml-8 mb-0 px-8 py-4 text-7xl inline-block leading-tight"
        >
          Fast by Default
        </h1>
        <p class="lead mt-6 text-gray-700">
          Fast by Default is a software development approach where speed and responsiveness are built into a system from the beginning, rather than added in a rescue mission after users complain. It treats performance as a core requirement that guides architecture, code, testing, deployment, and team habits, so that fast behaviour is the natural result of everyday work.
        </p>

        <p class="mt-8">A system is Fast by Default when:</p>
        <ol class="space-y-3">
          <li>
            Architecture creates room for speed by avoiding designs that guarantee slow behaviour.
          </li>
          <li>
            Developers see performance impact during daily work, not weeks later.
          </li>
          <li>
            Budgets and checks run automatically, preventing regressions from reaching production.
          </li>
          <li>
            Real user data shapes decisions, and teams respond based on what users actually experience.
          </li>
          <li>
            Speed is a shared responsibility, with engineers across roles protecting responsiveness for all users, devices, and regions.
          </li>
        </ol>

        <p class="mt-8">
          Fast by Default is not a tool or framework. It is a disciplined way of building software that stays fast as it grows in features, traffic, and team size.
        </p>

        <h2 class="mt-12">The Seven Principles of Fast by Default</h2>

        <ol class="space-y-4">
          <li>
            <strong>Design for speed before you write code</strong><br />
            Make performance a requirement during planning and architecture. Avoid chains of work, slow dependencies, and designs that guarantee delays.
          </li>
          <li>
            <strong>Make performance visible during development</strong><br />
            Use tools and workflows that show how each change affects speed. Developers should see slow tasks, blocking operations, and heavy assets as they work.
          </li>
          <li>
            <strong>Protect the experience with clear budgets</strong><br />
            Set limits for the things that slow users down. Enforce budgets for JavaScript size, API latency, startup cost, memory use, and render time. Let the tooling hold the line.
          </li>
          <li>
            <strong>Optimise complete user flows, not isolated screens</strong><br />
            Users experience journeys, not single pages or endpoints. Test and improve full flows, including the transitions, loading states, and interactions between steps.
          </li>
          <li>
            <strong>Use real-world data to guide decisions</strong><br />
            Base priorities on what users actually feel. Track key metrics in production, including Core Web Vitals, slow interactions, crashes, and long tasks on real devices and networks.
          </li>
          <li>
            <strong>Treat performance as a shared responsibility</strong><br />
            Speed is a team outcome. Everyone plays a part, from backend and frontend to design, QA, and DevOps. Good performance habits must be part of everyday work.
          </li>
          <li>
            <strong>Prevent decay through regular cleanup and review</strong><br />
            Performance declines naturally over time. Counter this by reviewing dependencies, removing dead code, resetting budgets, and auditing critical flows on a predictable cadence.
          </li>
        </ol>

        <h2 class="mt-12">The Fast by Default Cycle</h2>

        <p>
          The cycle has five stages. Together they create a continuous loop that keeps systems fast as they grow.
        </p>

        <div class="not-prose my-12 flex justify-center">
          <svg width="500" height="500" viewBox="0 0 500 500" class="max-w-full h-auto">
            <!-- Center circle -->
            <circle cx="250" cy="250" r="60" fill="#f8fafc" stroke="#334155" stroke-width="2"/>
            <text x="250" y="245" text-anchor="middle" font-size="14" font-weight="600" fill="#334155">Fast by</text>
            <text x="250" y="262" text-anchor="middle" font-size="14" font-weight="600" fill="#334155">Default</text>

            <!-- Architect (top) -->
            <circle cx="250" cy="80" r="55" fill="#1e293b" stroke="#334155" stroke-width="2"/>
            <text x="250" y="88" text-anchor="middle" font-size="16" font-weight="bold" fill="white">Architect</text>

            <!-- Implement (top right) -->
            <circle cx="400" cy="150" r="55" fill="#334155" stroke="#475569" stroke-width="2"/>
            <text x="400" y="158" text-anchor="middle" font-size="16" font-weight="bold" fill="white">Implement</text>

            <!-- Verify (bottom right) -->
            <circle cx="400" cy="350" r="55" fill="#475569" stroke="#64748b" stroke-width="2"/>
            <text x="400" y="358" text-anchor="middle" font-size="16" font-weight="bold" fill="white">Verify</text>

            <!-- Observe (bottom left) -->
            <circle cx="100" cy="350" r="55" fill="#64748b" stroke="#94a3b8" stroke-width="2"/>
            <text x="100" y="358" text-anchor="middle" font-size="16" font-weight="bold" fill="white">Observe</text>

            <!-- Refine (top left) -->
            <circle cx="100" cy="150" r="55" fill="#94a3b8" stroke="#cbd5e1" stroke-width="2"/>
            <text x="100" y="158" text-anchor="middle" font-size="16" font-weight="bold" fill="white">Refine</text>

            <!-- Arrows -->
            <defs>
              <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                <polygon points="0 0, 10 3, 0 6" fill="#334155" />
              </marker>
            </defs>

            <!-- Arrow from Architect to Implement -->
            <path d="M 295 100 Q 340 110 355 135" fill="none" stroke="#334155" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Arrow from Implement to Verify -->
            <path d="M 400 205 L 400 295" fill="none" stroke="#334155" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Arrow from Verify to Observe -->
            <path d="M 355 365 Q 250 380 145 365" fill="none" stroke="#334155" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Arrow from Observe to Refine -->
            <path d="M 100 295 L 100 205" fill="none" stroke="#334155" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Arrow from Refine to Architect -->
            <path d="M 145 135 Q 190 110 205 100" fill="none" stroke="#334155" stroke-width="3" marker-end="url(#arrowhead)"/>
          </svg>
        </div>

        <ol class="space-y-4">
          <li>
            <strong>Architect</strong><br />
            Start with designs that make fast behaviour possible. Reduce critical-path work, keep dependencies shallow, plan caching and data loading early, and choose rendering strategies that match your platform.
          </li>
          <li>
            <strong>Implement</strong><br />
            Write code with performance feedback available at every step. Developers should see long tasks, heavy bundles, slow queries, and blocking operations as they build features.
          </li>
          <li>
            <strong>Verify</strong><br />
            Check performance automatically in CI. Enforce budgets, run key tests, detect regressions, and block changes that would slow users down. Verification should be consistent and predictable.
          </li>
          <li>
            <strong>Observe</strong><br />
            Measure what real users experience in production. Track Core Web Vitals, latency, slow interactions, and device-level performance. Use observability tools to understand how the system behaves at scale.
          </li>
          <li>
            <strong>Refine</strong><br />
            Feed real-world data back into architecture and development. Fix bottlenecks, reset budgets when needed, simplify flows, and reduce complexity. Refinement keeps systems fast over time.
          </li>
        </ol>

        <hr class="my-8 border-gray-300" />

        <h3 class="text-lg font-semibold mt-6">How the Cycle Works</h3>

        <p>It repeats forever.</p>

        <p>
          Architect → Implement → Verify → Observe → Refine → back to Architect.
        </p>

        <p>
          A team that follows this cycle does not wait for incidents. Speed stays healthy because the loop runs as part of normal work.
        </p>
      </article>
    </div>
  </main>
</Layout>
