---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Fast by Default">
  <main class="min-h-screen bg-gray-50 py-16 px-4">
    <div class="max-w-4xl mx-auto">
      <article class="prose prose-lg prose-h2:mb-2 prose-h2:text-slate-700 prose-strong:font-semibold prose-strong:text-slate-600 mx-auto">
        <h1
          class="bg-gradient-to-r from-slate-800 to-slate-700 text-white -ml-8 mb-0 px-8 py-4 text-7xl inline-block leading-tight"
        >
          Fast by Default
        </h1>
        <p class="lead mt-6 text-gray-700">
          Fast by Default is a software development approach where speed and responsiveness are built into a system from the beginning, rather than added in a rescue mission after users complain. It treats performance as a core requirement that guides architecture, code, testing, deployment, and team habits, so that fast behaviour is the natural result of everyday work.
        </p>

        <p class="mt-8">A system is Fast by Default when:</p>
        <ol class="space-y-3">
          <li>
            Architecture creates room for speed by avoiding designs that guarantee slow behaviour.
          </li>
          <li>
            Developers see performance impact during daily work, not weeks later.
          </li>
          <li>
            Budgets and checks run automatically, preventing regressions from reaching production.
          </li>
          <li>
            Real user data shapes decisions, and teams respond based on what users actually experience.
          </li>
          <li>
            Speed is a shared responsibility, with engineers across roles protecting responsiveness for all users, devices, and regions.
          </li>
        </ol>

        <p class="mt-8">
          Fast by Default is not a tool or framework. It is a disciplined way of building software that stays fast as it grows in features, traffic, and team size.
        </p>

        <h2 class="mt-12">The Seven Principles of Fast by Default</h2>

        <ol class="space-y-4">
          <li>
            <strong>Design for speed before you write code</strong><br />
            Make performance a requirement during planning and architecture. Avoid chains of work, slow dependencies, and designs that guarantee delays.
          </li>
          <li>
            <strong>Make performance visible during development</strong><br />
            Use tools and workflows that show how each change affects speed. Developers should see slow tasks, blocking operations, and heavy assets as they work.
          </li>
          <li>
            <strong>Protect the experience with clear budgets</strong><br />
            Set limits for the things that slow users down. Enforce budgets for JavaScript size, API latency, startup cost, memory use, and render time. Let the tooling hold the line.
          </li>
          <li>
            <strong>Optimise complete user flows, not isolated screens</strong><br />
            Users experience journeys, not single pages or endpoints. Test and improve full flows, including the transitions, loading states, and interactions between steps.
          </li>
          <li>
            <strong>Use real-world data to guide decisions</strong><br />
            Base priorities on what users actually feel. Track key metrics in production, including Core Web Vitals, slow interactions, crashes, and long tasks on real devices and networks.
          </li>
          <li>
            <strong>Treat performance as a shared responsibility</strong><br />
            Speed is a team outcome. Everyone plays a part, from backend and frontend to design, QA, and DevOps. Good performance habits must be part of everyday work.
          </li>
          <li>
            <strong>Prevent decay through regular cleanup and review</strong><br />
            Performance declines naturally over time. Counter this by reviewing dependencies, removing dead code, resetting budgets, and auditing critical flows on a predictable cadence.
          </li>
        </ol>

        <h2 class="mt-12">The Fast by Default Cycle</h2>

        <p>
          The cycle has five stages. Together they create a continuous loop that keeps systems fast as they grow.
        </p>

        <ol class="space-y-4">
          <li>
            <strong>Architect</strong><br />
            Start with designs that make fast behaviour possible. Reduce critical-path work, keep dependencies shallow, plan caching and data loading early, and choose rendering strategies that match your platform.
          </li>
          <li>
            <strong>Implement</strong><br />
            Write code with performance feedback available at every step. Developers should see long tasks, heavy bundles, slow queries, and blocking operations as they build features.
          </li>
          <li>
            <strong>Verify</strong><br />
            Check performance automatically in CI. Enforce budgets, run key tests, detect regressions, and block changes that would slow users down. Verification should be consistent and predictable.
          </li>
          <li>
            <strong>Observe</strong><br />
            Measure what real users experience in production. Track Core Web Vitals, latency, slow interactions, and device-level performance. Use observability tools to understand how the system behaves at scale.
          </li>
          <li>
            <strong>Refine</strong><br />
            Feed real-world data back into architecture and development. Fix bottlenecks, reset budgets when needed, simplify flows, and reduce complexity. Refinement keeps systems fast over time.
          </li>
        </ol>

        <hr class="my-8 border-gray-300" />

        <h3 class="text-lg font-semibold mt-6">How the Cycle Works</h3>

        <p>It repeats forever.</p>

        <p>
          Architect → Implement → Verify → Observe → Refine → back to Architect.
        </p>

        <p>
          A team that follows this cycle does not wait for incidents. Speed stays healthy because the loop runs as part of normal work.
        </p>
      </article>
    </div>
  </main>
</Layout>
